if(typeof(breaks) == "double"){
breaklist <- rep(list(-Inf, breaks, Inf), length(types))
}
breaks = c(0, .15)
if(typeof(breaks) == "double"){
breaklist <- rep(list(-Inf, breaks, Inf), length(types))
}
breaklist
breaks
if(typeof(breaks) == "double"){
breaklist <- rep(list(-Inf, breaks, Inf), length(types))
} else if{
if(typeof(breaks) == "double"){
breaklist <- rep(list(-Inf, breaks, Inf), length(types))
} else if (typeof(breaks) == "list"){
breaklist <- rep(list(NA), length(types))
for(f in 1:F){
if(types[f] == "lv" & breaks[[f]] == NA){
breaklist[[f]] <- c(0, .25, .5)
}
if(types[f] == "lv"){
breaklist[[f]] <- c(-Inf, breaks[[f]], Inf)
}
if(types[f] == "nu" & breaks[[f]] == NA){
breaklist[[f]] <- c(0, 1)
}
if(types[f] == "nu"){
breaklist[[f]] <- c(-Inf, breaks[[f]], Inf)
}
}
}
breaklist
breaklist <- rep(list(-Inf, breaks, Inf), length(types))
breaklist
length(types)
list(-Inf, breaks, Inf)
breaklist <- rep(list(c(-Inf, breaks, Inf)), length(types))
breaklist
if(typeof(breaks) == "double"){
breaklist <- rep(list(c(-Inf, breaks, Inf)), length(types))
} else if (typeof(breaks) == "list"){
breaklist <- rep(list(NA), length(types))
for(f in 1:F){
if(types[f] == "lv" & breaks[[f]] == NA){
breaklist[[f]] <- c(0, .25, .5)
}
if(types[f] == "lv"){
breaklist[[f]] <- c(-Inf, breaks[[f]], Inf)
}
if(types[f] == "nu" & breaks[[f]] == NA){
breaklist[[f]] <- c(0, 1)
}
if(types[f] == "nu"){
breaklist[[f]] <- c(-Inf, breaks[[f]], Inf)
}
}
}
ids <- expand.grid(1:n1, 1:n2)
ids_1 <- ids[, 1]
ids_2 <- ids[, 2]
comparisons <- vector(mode = "list", length = FF)
ohe <- vector(mode = "list", length = FF)
# FS agreement levels
for(f in 1:FF){
if(types[f] == "bi"){
comp <- df1[ids_1, fields_1[f]] == df2[ids_2, fields_2[f]]
comp <- (!comp) + 1
comparisons[[f]] <- factor(comp)
}
if(types[f] == "lv"){
if(distance_metric == "Levenshtein"){
distance <- RecordLinkage::levenshteinDist(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]))
}
if(distance_metric == "Damerau-Levenshtein"){
# Damerau-Levenshtein distance, so transpositions count as 1.
# In contrast, BRL uses standard Levenshtein, so transpositions count as 2
distance <- 1 - levitate::lev_ratio(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]),
useNames = F)
}
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer() %>%
factor()
comparisons[[f]] <- comp
}
if(types[f] == "nu"){
distance <- abs(df1[ids_1, fields_1[f]] - df2[ids_2, fields_2[f]])
comp <- cut(distance,
breaks = breaklist[[f]],
include.lowest = T) %>%
as.integer()
comparisons[[f]] <- comp
}
}
distance_metric = "Levenshtein"
# FS agreement levels
for(f in 1:FF){
if(types[f] == "bi"){
comp <- df1[ids_1, fields_1[f]] == df2[ids_2, fields_2[f]]
comp <- (!comp) + 1
comparisons[[f]] <- factor(comp)
}
if(types[f] == "lv"){
if(distance_metric == "Levenshtein"){
distance <- RecordLinkage::levenshteinDist(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]))
}
if(distance_metric == "Damerau-Levenshtein"){
# Damerau-Levenshtein distance, so transpositions count as 1.
# In contrast, BRL uses standard Levenshtein, so transpositions count as 2
distance <- 1 - levitate::lev_ratio(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]),
useNames = F)
}
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer() %>%
factor()
comparisons[[f]] <- comp
}
if(types[f] == "nu"){
distance <- abs(df1[ids_1, fields_1[f]] - df2[ids_2, fields_2[f]])
comp <- cut(distance,
breaks = breaklist[[f]],
include.lowest = T) %>%
as.integer()
comparisons[[f]] <- comp
}
}
fields_1 = fields
fields_2 = fields
# FS agreement levels
for(f in 1:FF){
if(types[f] == "bi"){
comp <- df1[ids_1, fields_1[f]] == df2[ids_2, fields_2[f]]
comp <- (!comp) + 1
comparisons[[f]] <- factor(comp)
}
if(types[f] == "lv"){
if(distance_metric == "Levenshtein"){
distance <- RecordLinkage::levenshteinDist(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]))
}
if(distance_metric == "Damerau-Levenshtein"){
# Damerau-Levenshtein distance, so transpositions count as 1.
# In contrast, BRL uses standard Levenshtein, so transpositions count as 2
distance <- 1 - levitate::lev_ratio(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]),
useNames = F)
}
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer() %>%
factor()
comparisons[[f]] <- comp
}
if(types[f] == "nu"){
distance <- abs(df1[ids_1, fields_1[f]] - df2[ids_2, fields_2[f]])
comp <- cut(distance,
breaks = breaklist[[f]],
include.lowest = T) %>%
as.integer()
comparisons[[f]] <- comp
}
}
n_levels <- lapply(comparisons, levels) %>%
sapply(., length)
View(comparisons)
ids <- expand.grid(1:n1, 1:n2)
ids_1 <- ids[, 1]
ids_2 <- ids[, 2]
comparisons <- vector(mode = "list", length = FF)
ohe <- vector(mode = "list", length = FF)
# FS agreement levels
for(f in 1:FF){
if(types[f] == "bi"){
comp <- df1[ids_1, fields_1[f]] == df2[ids_2, fields_2[f]]
comp <- (!comp) + 1
comparisons[[f]] <- factor(comp)
}
if(types[f] == "lv"){
if(distance_metric == "Levenshtein"){
distance <- RecordLinkage::levenshteinDist(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]))
}
if(distance_metric == "Damerau-Levenshtein"){
# Damerau-Levenshtein distance, so transpositions count as 1.
# In contrast, BRL uses standard Levenshtein, so transpositions count as 2
distance <- 1 - levitate::lev_ratio(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]),
useNames = F)
}
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer() %>%
factor(., seq_len(length(breaklist[[f]]) - 1))
comparisons[[f]] <- comp
}
if(types[f] == "nu"){
distance <- abs(df1[ids_1, fields_1[f]] - df2[ids_2, fields_2[f]])
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer( )%>%
factor(., seq_len(length(breaklist[[f]]) - 1))
comparisons[[f]] <- comp
}
}
n_levels <- lapply(comparisons, levels) %>%
sapply(., length)
# Convert to one-hot encoding
# TODO: Test for speed vs onehot encoding function, or lapply
for(f in 1:FF){
ohe[[f]] <- matrix(0, nrow = n1 * n2, ncol = n_levels[f])
for(ell in 1:n_levels[f]){
ohe[[f]][comparisons[[f]] == ell, ell] <- 1
}
}
ohe <- comparisons %>%
lapply(. , function(x){
if(any(is.na(x)) == T){
scorecard::one_hot(data.frame(x), nacol_rm = T) %>%
as.matrix()
} else {
scorecard::one_hot(data.frame(x)) %>%
as.matrix()
}
}) %>%
do.call(data.frame, .)
ohe <- vector(mode = "list", length = FF)
# Convert to one-hot encoding
# TODO: Test for speed vs onehot encoding function, or lapply
for(f in 1:FF){
ohe[[f]] <- matrix(0, nrow = n1 * n2, ncol = n_levels[f])
for(ell in 1:n_levels[f]){
ohe[[f]][comparisons[[f]] == ell, ell] <- 1
}
}
# Convert to one-hot encoding
# TODO: Test for speed vs onehot encoding function, or lapply
for(f in 1:FF){
ohe[[f]] <- matrix(0, nrow = n1 * n2, ncol = n_levels[f])
for(ell in 1:n_levels[f]){
ohe[[f]][comparisons[[f]] == ell, ell] <- 1
}
}
ids <- expand.grid(1:n1, 1:n2)
ids_1 <- ids[, 1]
ids_2 <- ids[, 2]
comparisons <- vector(mode = "list", length = FF)
ohe <- vector(mode = "list", length = FF)
# FS agreement levels
for(f in 1:FF){
if(types[f] == "bi"){
comp <- df1[ids_1, fields_1[f]] == df2[ids_2, fields_2[f]]
comp <- (!comp) + 1
#comparisons[[f]] <- factor(comp)
comparisons[[f]] <- comp
}
if(types[f] == "lv"){
if(distance_metric == "Levenshtein"){
distance <- RecordLinkage::levenshteinDist(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]))
}
if(distance_metric == "Damerau-Levenshtein"){
# Damerau-Levenshtein distance, so transpositions count as 1.
# In contrast, BRL uses standard Levenshtein, so transpositions count as 2
distance <- 1 - levitate::lev_ratio(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]),
useNames = F)
}
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer()
#
# %>%
#   factor(., seq_len(length(breaklist[[f]]) - 1))
comparisons[[f]] <- comp
}
if(types[f] == "nu"){
distance <- abs(df1[ids_1, fields_1[f]] - df2[ids_2, fields_2[f]])
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer( )
# %>%
#   factor(., seq_len(length(breaklist[[f]]) - 1))
comparisons[[f]] <- comp
}
}
# FS agreement levels
for(f in 1:FF){
if(types[f] == "bi"){
comp <- df1[ids_1, fields_1[f]] == df2[ids_2, fields_2[f]]
comp <- (!comp) + 1
comparisons[[f]] <- factor(comp)
}
if(types[f] == "lv"){
if(distance_metric == "Levenshtein"){
distance <- RecordLinkage::levenshteinDist(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]))
}
if(distance_metric == "Damerau-Levenshtein"){
# Damerau-Levenshtein distance, so transpositions count as 1.
# In contrast, BRL uses standard Levenshtein, so transpositions count as 2
distance <- 1 - levitate::lev_ratio(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]),
useNames = F)
}
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer() %>%
factor(., seq_len(length(breaklist[[f]]) - 1))
comparisons[[f]] <- comp
}
if(types[f] == "nu"){
distance <- abs(df1[ids_1, fields_1[f]] - df2[ids_2, fields_2[f]])
comp <- cut(distance,
breaks = breaklist[[f]]) %>%
as.integer( ) %>%
factor(., seq_len(length(breaklist[[f]]) - 1))
comparisons[[f]] <- comp
}
}
f = 1
types
# Damerau-Levenshtein distance, so transpositions count as 1.
# In contrast, BRL uses standard Levenshtein, so transpositions count as 2
distance <- 1 - levitate::lev_ratio(as.character(df1[ids_1, fields_1[f]]),
as.character(df2[ids_2, fields_2[f]]),
useNames = F)
comp <- cut(distance,
breaks = breaklist[[f]])
comp <- as.integer(comp)
comp <- factor(comp, seq_len(length(breaklist[[f]]) - 1))
roxygen2::roxygenise()
df1 <- read.csv("../../bk_vabl/data/febrl_4_A.csv") %>%
arrange(rec_id) %>%
mutate(rec_id = row_number()) %>%
.[1:100, ]
df2 <- read.csv("../../bk_vabl/data/febrl_4_B.csv") %>%
arrange(rec_id) %>%
mutate(rec_id = row_number()) %>%
.[1:100, ]
n1 <- nrow(df1)
n2 <- nrow(df2)
Z_true <- seq(1:100)
fields <- c(2, 3, 8, 10, 11)
types <- c("lv", "lv","bi", "bi", "bi")
breaks = c(0, .15)
cd <- compare_records(df1, df2, fields = fields, types = types,
breaks = breaks)
hash <- hash_comparisons(cd, all_patterns = F)
out <- vabl(hash)
names(out)[1] == "Z"
names(out)[1] == "pattern_weights"
n2 <- hash$n2
pattern_probs <- lapply(1:n2, function(j){
out$pattern_weights/out$C[j]
})
possible_records <- lapply(1:n2, function(j){
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j])
data.frame(record, prob)
})
max_prob <- lapply(possible_records, function(x){
x[which.max(x$prob), ]
}) %>%
do.call(rbind, .)
best_match <- max_prob$record
prob_best_match <- max_prob$prob
prob_no_link <- out$b_pi/out$C
link_indicator <- best_match > 0
results <- estimate_links(out, hash)
results$Z_hat
df1 <- read.csv("../../bk_vabl/data/febrl_4_A.csv") %>%
arrange(rec_id) %>%
mutate(rec_id = row_number())
df2 <- read.csv("../../bk_vabl/data/febrl_4_B.csv") %>%
arrange(rec_id) %>%
mutate(rec_id = row_number())
n1 <- nrow(df1)
n2 <- nrow(df2)
Z_true <- seq(1:100)
fields <- c(2, 3, 8, 10, 11)
types <- c("lv", "lv","bi", "bi", "bi")
breaks = c(0, .15)
start <- tic()
cd <- compare_records(df1, df2, fields = fields, types = types,
breaks = breaks)
hash <- hash_comparisons(cd, all_patterns = F)
out <- vabl(hash)
results <- estimate_links(out, hash)
n2 <- hash$n2
pattern_probs <- lapply(1:n2, function(j){
out$pattern_weights/out$C[j]
})
n2
possible_records <- lapply(1:n2, function(j){
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j])
#data.frame(record, prob)
list(record = record,
prob = prob)
})
View(possible_records)
possible_records <- lapply(1:n2, function(j){
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j])
data.frame(record)
})
possible_records <- lapply(1:n2, function(j){
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j])
data.frame(prob)
})
possible_records <- lapply(1:n2, function(j){
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j])
prob
})
View(possible_records)
possible_records
thing <- sapply(possible_records, function(x){
is.na(x) %>%
sum()
})
which(thing > 0)
look_at <- sapply(possible_records, function(x){
is.na(x) %>%
sum()
}) %>%
which()
look_at <- sapply(possible_records, function(x){
is.na(x) %>%
sum()
}) %>%
which(.)
look_at <- sapply(possible_records, function(x){
is.na(x) %>%
sum()
}) %>%
which(. > 0)
look_at <- sapply(possible_records, function(x){
is.na(x) %>%
sum()
})
thing <- sapply(possible_records, function(x){
is.na(x) %>%
sum()
})
look_at <- which(thing > 0)
possible_records[[look_at[1]]]
possible_records[[look_at[2]]]
possible_records[[look_at[3]]]
j = look_at[1]
record <- c(hash$flags[[j]]$eligible_records, 0)
hash$flags[[j]]
c(hash$flags[[j]]$eligible_records, 0)
pattern_probs[[j]]
hash$flags[[j]]$eligible_patterns
View(hash)
possible_records <- lapply(1:n2, function(j){
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j])
data.frame(record, prob)
#record
})
j
record <- c(hash$flags[[j]]$eligible_records, 0)
record
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j])
prob
j = 1
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j])
prob
record
pattern_probs[[j]]
out$pattern_weights
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j]) %>%
unname()
data.frame(record, prob)
j = look_at[1]
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j]) %>%
unname()
data.frame(record, prob)
possible_records <- lapply(1:n2, function(j){
record <- c(hash$flags[[j]]$eligible_records, 0)
prob <- c(pattern_probs[[j]][hash$flags[[j]]$eligible_patterns],
exp(digamma(out$b_pi)) / out$C[j]) %>%
unname()
data.frame(record, prob)
#record
})
devtools::load_all(".")
results <- estimate_links(out, hash)
results$Z_hat
evaluate_links(results$Z_hat, Z_true, n1)
Z_true <- seq(1:5000)
evaluate_links(results$Z_hat, Z_true, n1)
